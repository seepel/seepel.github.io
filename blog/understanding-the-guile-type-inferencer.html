<!DOCTYPE html><head><meta charset="utf-8" /><title>Understanding the Guile Type Inferencer - seanplynch.com</title><link rel="stylesheet" href="/css/main.css" /><link rel="stylesheet" href="/css/normalize.css" /><link rel="stylesheet" href="/css/prism.css" /><script src="/js/prism.js"></script></head><body><div class="container"><h1><a href="/">seanplynch.com</a></h1><h2>Understanding the Guile Type Inferencer</h2><div><p>Lately I've been investigating what it would take to provide some sort of type
analysis to the scheme programming language. In the process I wanted to learn
a bit about how the Guile Scheme type system works. Naturally my first step was
to ask the kind folks over at the #guile irc channel for some pointers. Along
the way someone over there was interested as well, and asked me to write up
what I found. It's been a while since I've blogged, so here we are.</p><p>This topic really digs into the internals of Guile's compiler, which is of
course a very large topic. I'll also try my best to explain the bits that a
reader absolutely must know to understand the main points. I'll try to only
assume a reasonably proficient understanding of programming (in any language)
and link to resources that provide more in depth background on the Guile
compiler itself. I don't think a reader <em>must</em> know the Scheme programming
language in order to understand what's happening here, but we will be using the
scheme language throughout the post. Here is a quick mental mapping that should
get you through.</p><pre><code class="language-js">// A top level variable
var foo = &quot;foo&quot;
// A top level function definition
function foo(bar, baz) { 
  return bar + baz 
} 
// A function call
foo(1, 2)</code></pre><pre><code class="language-scheme">;; A top level variable
(define foo &quot;foo&quot;)
;; A top level function (procedure) definition
(define (foo bar baz) 
  (+ bar baz))
;; A function call
(foo 1 2)</code></pre><p>One last note before we get started. I'm <em>almost</em> going to walk through all the
steps that I used to learn this topic. I say <em>almost</em> because along the way I
went down many paths that proved to be useless or just plain wrong. Here I only
show the questions that led to useful answers. With that, let's dig in!</p><h3>The Guile Compiler</h3><p>In order to understand the details here, it is incredibly helpful to understand
the <a href="https://www.gnu.org/software/guile/manual/html_node/Compiler-Tower.html">Guile Compiler Tower</a>.
So best to go read that page and come back (don't worry it's not long). It is
also pretty helpful to read the entire <a href="https://www.gnu.org/software/guile/manual/html_node/Compiling-to-the-Virtual-Machine.html">Compiling to the Virtual Machine</a>
section. But don't worry if you don't understand everything, or just don't have
the time. We'll cover the important bits here. In particular the Intermediate
Language (IL) that we are interested in here is the
<a href="https://www.gnu.org/software/guile/manual/html_node/Continuation_002dPassing-Style.html">Continuation Passing Style</a>
IL, as that is the compiler pass that does type analysis.</p><h3>Continuation Passing Style (CPS)</h3><p>Without getting all <strong>Compiler Theoryâ„¢</strong> on you, for our purposes it will
probably suffice to consider CPS as a big goto table. Yes,
<a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">goto is considered harmful</a>,
but as a tool for a compiler back-end it is actually pretty practical.</p><h4>Compiling to CPS</h4><p>Guile is great, it exposes the entire compiler to the user, so we can start
exploring right away. For our example let's consider a simple &quot;hello world&quot;
program.</p><pre><code class="language-scheme">(define (main)
  (display &quot;Hello world!\n&quot;))</code></pre><p>In order to compile this to CPS we can just use the compile procedure in the
Guile repl.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (define hello-world
                      '(define (main)
                         (display &quot;Hello world!\n&quot;)))
scheme@(guile-user)&gt; (compile hello-world #:to 'cps)
$1 = #&lt;intmap 0-18&gt;</code></pre><p>wtf is that <code>#&lt;intmap 0-21&gt;</code> thing? Well, like I said, this is essentially a
big goto lookup table, so Guile has an efficient data structure for that: the
intmap found in the <a href="https://www.gnu.org/software/guile/docs/docs-2.2/guile-ref/CPS-Soup.html">CPS Soup</a>
section of the manual. Now, let's import the intmap module so that we can
inspect what the compiler just gave us. At the Guile repl again we call the
<code>use-modules</code> procedure.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (use-modules (language cps intmap))</code></pre><p>Now we can start to poke at our intmap, but it is probably also useful to
assign a sensible name to this intmap, so let's do that now. We'll just use the
identifier that the repl automatically assigned to the result of our
expression (namely <code>$1</code>).</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (define hello-world-cps $1)</code></pre><h4>Poking at CPS</h4><p>An intmap is essentially a mapping of small integers to CPS values. Let's see
what the first value (at index <code>0</code>) is, for that we'll use <code>intmap-ref</code>.
<code>intmap-ref</code> is very similar to <code>list-ref</code> and <code>vector-ref</code>.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (intmap-ref hello-world-cps 0)
$2 = #&lt;cps (kfun () 0 1 18)&gt;</code></pre><p>Here we can see that we got some sort of CPS value out. It is a cps record of
type <code>$kfun</code>. You can go find <em>all</em> the possible CPS record types in the
<a href="https://www.gnu.org/software/guile/docs/docs-2.2/guile-ref/CPS-in-Guile.html#CPS-in-Guile">CPS in Guile</a>
section of the manual, but (spoiler alert <code>$kfun</code> defines a function entry).
Looking at that manual page we see that <code>$kfun</code> has five arguments.</p><ol><li><p><strong>src</strong>
This is the source location of the original scheme expression. First
of all this property isn't printed. And second of all, we didn't
compile our program from a file anyway, so this would be pretty
useless for us. So we'll just ignore it.</p></li><li><p><strong>meta</strong>
The <code>meta</code> field is some sort of association list describing the
properties of the procedure (function). We aren't entirely sure
what this is yet. But none of our functions have arguments, and
there are no variables, so it should come as no surprise that it is
empty.</p></li><li><p><strong>self</strong>
The documentation for the <code>self</code> field says:</p><blockquote><p>self is a variable bound to the procedure being called, and which may be
used for self-references</p></blockquote><p>So it should make sense that this value is <code>0</code>. Remember we are looking at
the CPS value at index <code>0</code> in our intmap.</p></li><li><p><strong>tail</strong>
The documentation for the <code>tail</code> field says:</p><blockquote><p>tail is the label of the $ktail for this function, corresponding to the
functionâ€™s tail continuation</p></blockquote><p>So it seems that this field should be the &quot;goto&quot; label for when we are done
with this function and are going to return.</p></li><li><p><strong>clause</strong>
The documentation for the <code>clause</code> field says:</p><blockquote><p>clause is the label of the first $kclause for the first case-lambda clause
in the function, or otherwise #f</p></blockquote><p>So this should be the &quot;goto&quot; label for the first expression of the function
body.</p></li></ol><p>Well, that was fun. If we look back at what the repl printed initially this all
lines up pretty nicely.</p><ol><li>src: not printed</li><li>meta: <code>'()</code></li><li>self: <code>0</code></li><li>tail: <code>1</code></li><li>clause: <code>18</code></li></ol><h4>What's in my intmap?</h4><p>Of course we could do the same for all indices in the intmap from 0-18, but
that sounds annoying. Let's instead write a function to do it for us! First
we'll need another module <code>(language cps utils)</code>. This will give us two
very useful functions <code>intmap-keys</code> and <code>intmap-map</code>, along with a bunch of
other goodies that we won't need today.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (use-modules (language cps utils))</code></pre><p>Now let's write our function, doesn't have to be <em>too</em> special.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (define (print-intmap intmap)
                       (intmap-map (lambda entry
                                     (format #t &quot;~a\n&quot; entry))
                                   intmap))</code></pre><p>And now we're ready to see what our intmap contains!</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (print-intmap hello-world-cps)
(0 #&lt;cps (kfun () 0 1 18)&gt;)
(1 #&lt;cps (ktail)&gt;)
(2 #&lt;cps (kargs (val) (3) (continue 1 (values 3)))&gt;)
(3 #&lt;cps (kargs () () (continue 2 (unspecified)))&gt;)
(4 #&lt;cps (kargs (arg) (4) (continue 3 (primcall scm-set!/immediate (box . 1) 2 4)))&gt;)
(5 #&lt;cps (ktail)&gt;)
(6 #&lt;cps (kargs (arg) (7) (continue 5 (call 6 7)))&gt;)
(7 #&lt;cps (kargs (arg) (6) (continue 6 (const &quot;Hello world!\n&quot;)))&gt;)
(8 #&lt;cps (kargs (box) (8) (continue 7 (primcall scm-ref/immediate (box . 1) 8)))&gt;)
(9 #&lt;cps (kargs () () (continue 8 (primcall cached-toplevel-box (0 display #t))))&gt;)
(10 #&lt;cps (kclause (() () #f () #f) 9)&gt;)
(11 #&lt;cps (kfun ((name . main)) 5 5 10)&gt;)
(12 #&lt;cps (kargs () () (continue 4 (fun 11)))&gt;)
(13 #&lt;cps (kargs (module) (9) (continue 12 (primcall cache-current-module! (0) 9)))&gt;)
(14 #&lt;cps (kargs (main) (2) (continue 13 (primcall current-module #f)))&gt;)
(15 #&lt;cps (kargs (arg) (10) (continue 14 (primcall define! #f 1 10)))&gt;)
(16 #&lt;cps (kargs (mod) (1) (continue 15 (const main)))&gt;)
(17 #&lt;cps (kargs () () (continue 16 (primcall current-module #f)))&gt;)
(18 #&lt;cps (kclause (() () #f () #f) 17)&gt;)
$3 = #&lt;intmap 0-18&gt;</code></pre><p>Whew! That's a lot of stuff! That's because there is a lot of implicit control
flow in the higher level scheme language compared to the CPS IL that makes all
of that control flow explicit. Let's dissect this.</p><p>We've already seen that our compiled CPS starts at index 0 with some function,
and that the first expression in that function is at index 18. Nearly every
expression I've compiled follows this format. The entry to the program is at
index 0, and then there is some boilerplate at the very end of the intmap.
Here we see that from indices 18-17 Guile is setting up the current module
environment.</p><p>I'm afraid we can't tell much about the first field of the <code>$kclause</code> record at
index 18. Like the <code>meta</code> field of the first <code>kfun</code> record we encountered, it
is empty, and I suppose we also kind of expect it to be empty. Anyway, here is
what the documentation says:</p><blockquote><p><strong>CPS Continuation: $kclause arity cont alternate</strong></p><p>A clause of a function with a given arity. Applications of a function with
a compatible set of actual arguments will continue to the continuation
labelled cont, a $kargs instance representing the clause body. If the
arguments are incompatible, control proceeds to alternate, which is a
$kclause for the next clause, or #f if there is no next clause.</p></blockquote><p>At any rate it is a sure bet that after this <code>$kclause</code> we jump to index 17
where we encounter a <code>$kargs</code> record. Here's what the documentation has to say
about that:</p><blockquote><p><strong>CPS Continuation: $kargs names vars term</strong></p></blockquote><blockquote><p>Bind the incoming values to the variables <em>vars</em>, with original names
<em>names</em>, and then evaluate <em>term</em>.</p></blockquote><p>So this seems like it is pretty much <code>let</code>, and that makes sense, even though
ours is empty. The reason for that is that the <code>current-module</code> <code>$primcall</code>
record takes no arguments. But don't worry, next we jump to index 16 where we
see a <code>$kargs</code> record that <em>does</em> have a parameter. This one is called <code>mod</code>
and it is the result of the <code>current-module</code> call we just stepped through.
It's assigned to variable <code>1</code>. We aren't quite sure yet <em>why</em> this variable is
associated to index 1 though. It could be an arbitrary number, or it could
relate back to our CPS index 1.  So for now just remember that the
current-module is located at variable index 1. From here we continue to index
15 with the constant symbol <code>'main</code>. At index 15 we see that we now call the
<code>define!</code> primitive with the variable at index 1 (<code>(current-module)</code>),
and the variable at index 10 (<code>(const main)</code>). As far as we can tell this
places the <code>main</code> symbol in our module. For the documentation on these
primitive calls you'll have to jump over to the
<a href="https://www.gnu.org/software/guile/manual/html_node/Intrinsic-Call-Instructions.html">Intrinsic Call Instructions</a>
section of the manual. Then we jump through indices 14-13 which seems to be
more environment setup, though I can't seem to find the documentation for this.
Finally once we jump through index 12 we reach our main function. He we jump to
index 4 with the value of <code>(fun 11)</code>. If we quickly scan up we can see our
function body starting at index 11 and ending with the <code>$ktail</code> record at index 5.
Then from indices 4-1 we see the ending boilerplate for the current module. We'll skip
over this part.</p><h4>Where is <em>my</em> code?</h4><p>As we've seen, our function body is located across indices 11-5.
Here we see something slightly different though. The
<code>meta</code> field of our <code>$kfun</code> at index 11 actually has some values! In our
case it is just the name of the function because it takes no arguments. Then we
see that the <code>self</code> field is actually index 5 and the <code>tail</code> field is also at
index 5, and the <code>clause</code> field is at index 10 as expected. The self and tail
fields being the same seems to indicate that this function cannot recurse,
however that may be a tenuous assumption. At any rate, let's move on to our
function body at index 10.</p><p>Again we see a relatively empty <code>$kclause</code> that forwards us to
index 9 where see another empty <code>$kargs</code> record that continues to index 8
assigning the <code>display</code> box that we just evaluated into variable 8, named <code>box</code>
and continues to index 7 by unboxing our <code>display</code> procedure. At index 7 we see
that we store our unboxed <code>display</code> procedure at variable 6 and continue
to index 6 with our <code>&quot;Hello world!\n&quot;</code> constant string. At index 6 we see that
our string constant is assigned to variable 7. Then we continue to index 5 with
the result of <code>(call 6 7)</code>. Our <code>display</code> function is stored in variable 6, and
our constant string is stored in variable 7, so you can think of this as
<code>(call display &quot;Hello world!\n&quot;)</code>. From there we continue to our procedure's
<code>$ktail</code> record which means this is the entire body. And from there we jump
back to index 4 to finish up the program's entry <code>$kfun</code>.</p><p>After a few shuffling around of arguments we finally arrive at the <code>$ktail</code> of
the entire program at index 1. Remember back when we started our journey that
the <code>tail</code> field of the entry function was located at index 1? Well we're done
now! Yay!</p><h3>Wait Sean, didn't you say something about types?</h3><p>Whew, yes. Let's figure out what Guile thinks of our types shall we? For this
we will need to deviate from the manual and look at some code ðŸ˜±. Here we will
want to dig through the Guile code-base for something that looks like it does
some type inference. Lucky for you I did just that and found the module
<code>(language cps types)</code>. You can find it in the Guile source tree at the path
<code>module/language/cps/types.scm</code>. Yes, it does sound like a pain to go find the
Guile source code and open this file in a text editor. So here is a snippet
from the top of the file that gives a quick overview.</p><pre><code class="language-scheme">;;; Commentary:
;;;
;;; Type analysis computes the possible types and ranges that values may
;;; have at all program positions.  This analysis can help to prove that
;;; a primcall has no side-effects, if its arguments have the
;;; appropriate type and range.  It can also enable constant folding of
;;; type predicates and, in the future, enable the compiler to choose
;;; untagged, unboxed representations for numbers.
;;;
;;; For the purposes of this analysis, a &quot;type&quot; is an aspect of a value
;;; that will not change.  Guile's CPS intermediate language does not
;;; carry manifest type information that asserts properties about given
;;; values; instead, we recover this information via flow analysis,
;;; garnering properties from type predicates, constant literals,
;;; primcall results, and primcalls that assert that their arguments are
;;; of particular types.
;;;
;;; A range denotes a subset of the set of values in a type, bounded by
;;; a minimum and a maximum.  The precise meaning of a range depends on
;;; the type.  For real numbers, the range indicates an inclusive lower
;;; and upper bound on the integer value of a type.  For vectors, the
;;; range indicates the length of the vector.  The range is the union of
;;; the signed and unsigned 64-bit ranges.  Additionally, the minimum
;;; bound of a range may be -inf.0, and the maximum bound may be +inf.0.
;;; For some types, like pairs, the concept of &quot;range&quot; makes no sense.
;;; In these cases we consider the range to be -inf.0 to +inf.0.
;;;
;;; Types are represented as a bitfield.  Fewer bits means a more precise
;;; type.  Although normally only values that have a single type will
;;; have an associated range, this is not enforced.  The range applies
;;; to all types in the bitfield.  When control flow meets, the types and
;;; ranges meet with the union operator.
;;;
;;; It is not practical to precisely compute value ranges in all cases.
;;; For example, in the following case:
;;;
;;;   (let lp ((n 0)) (when (foo) (lp (1+ n))))
;;;
;;; The first time that range analysis visits the program, N is
;;; determined to be the exact integer 0.  The second time, it is an
;;; exact integer in the range [0, 1]; the third, [0, 2]; and so on.
;;; This analysis will terminate, but only after the positive half of
;;; the 64-bit range has been fully explored and we decide that the
;;; range of N is [0, +inf.0].  At the same time, we want to do range
;;; analysis and type analysis at the same time, as there are
;;; interactions between them, notably in the case of `sqrt' which
;;; returns a complex number if its argument cannot be proven to be
;;; non-negative.  So what we do instead is to precisely propagate types
;;; and ranges when propagating forward, but after the first backwards
;;; branch is seen, we cause backward branches that would expand the
;;; range of a value to saturate that range towards positive or negative
;;; infinity (as appropriate).
;;;
;;; A naive approach to type analysis would build up a table that has
;;; entries for all variables at all program points, but this has
;;; N-squared complexity and quickly grows unmanageable.  Instead, we
;;; use _intmaps_ from (language cps intmap) to share state between
;;; connected program points.
;;;
</code></pre><p>This looks like a pretty good description of a Lattice Constraint Propagation
algorithm. The tricky bit might be that it seems like Guile handles dynamic
ranges which I personally haven't found in the literature. Of course, for this
type of type inference (no pun intended, but certainly appreciated), I've actually had a hard time finding
a wealth of information. There is <em>a lot</em> of information on Hindley-Milner
style type systems though, and I'm only one man (who wasn't trained in computer
science), so your mileage may vary. Anywho, this sounds like what we're looking
for, so how can I run it in the repl?</p><p>Well, in particular there is one procedure that looks interesting called
<code>infer-types</code>. Here is an excerpt of the leading comment and doc-string that
I pulled from whatever Guile-3.0 version I currently have checked out.</p><pre><code class="language-scheme">;; For best results, the labels in the function starting should be
;; topologically sorted (renumbered).  Otherwise the backward branch
;; detection mentioned in the module commentary will trigger for
;; ordinary forward branches.
(define (infer-types conts kfun)
  &quot;Compute types for all variables bound in the function labelled
@var{kfun}, from @var{conts}.  Returns an intmap mapping labels to type
entries.

A type entry is a vector that describes the types of the values that
flow into and out of a labelled expression.  The first slot in the type
entry vector corresponds to the types that flow in, and the rest of the
slots correspond to the types that flow out.  Each element of the type
entry vector is an intmap mapping variable name to the variable's
inferred type.  An inferred type is a 3-vector of type, minimum, and
maximum, where type is a bitset as a fixnum.&quot;
  ...)
</code></pre><p>It seems like once we have our CPS we should be able to call this procedure
with it (somehow) to get the types out. Through some trial and error I figured
out that the parameters you want to pass are:</p><ol><li><strong>conts</strong>
This is your program's CPS representation in intmap form. So in our case
this would be <code>hello-world-cps</code></li><li><strong>kfun</strong>
This is an index into your intmap pointing at <em>any</em> <code>$kfun</code> value.</li></ol><p>Let's call this procedure! Index 0 seems like as good a choice as any right?
We'll ignore the whole comment about sorting from the source. I'm sure it is
improtant, but our case is so simple let's hope it doesn't actually cause a
problem. When we call
<code>compile</code> on our simple function does it already spit out a sorted intmap?
Â¯_(ãƒ„)_/Â¯. We'll import the types module and then call <code>infer-types</code> with
our cps.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (use-modules (language cps types))
scheme@(guile-user)&gt; (infer-types hello-world-cps 0)
$4 = #&lt;intmap 0-4,12-18&gt;</code></pre><h4>But What Does it all <strong>Mean</strong>?</h4><p>Hey, look at that, we have another intmap. Let's assign it to some meaningful
name and then peek at what's inside.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (define hello-world-types $4)
scheme@(guile-user)&gt; (print-intmap hello-world-types)
(0 #(#&lt;intmap&gt; #&lt;intmap 0&gt;))
(1 #(#&lt;intmap 0-4,9-10&gt;))
(2 #(#&lt;intmap 0-4,9-10&gt; #&lt;intmap 0-4,9-10&gt;))
(3 #(#&lt;intmap 0-2,4,9-10&gt; #&lt;intmap 0-4,9-10&gt;))
(4 #(#&lt;intmap 0-2,4,9-10&gt; #&lt;intmap 0-2,4,9-10&gt;))
(12 #(#&lt;intmap 0-2,9-10&gt; #&lt;intmap 0-2,4,9-10&gt;))
(13 #(#&lt;intmap 0-2,9-10&gt; #&lt;intmap 0-2,9-10&gt;))
(14 #(#&lt;intmap 0-2,10&gt; #&lt;intmap 0-2,9-10&gt;))
(15 #(#&lt;intmap 0-1,10&gt; #&lt;intmap 0-2,10&gt;))
(16 #(#&lt;intmap 0-1&gt; #&lt;intmap 0-1,10&gt;))
(17 #(#&lt;intmap 0&gt; #&lt;intmap 0-1&gt;))
(18 #(#&lt;intmap 0&gt; #&lt;intmap 0&gt;))
$5 = #&lt;intmap 0-4,12-18&gt;</code></pre><p>True to the source code's word we have an intmap of vectors that contain
intmaps. There is one particular line in the source that I'd like to call out
(because at first I only skimmed this file, and so it took me <em>forever</em> to
realize).</p><blockquote><p>The first slot in the type entry vector corresponds to the types that flow
in, and the rest of the slots correspond to the types that flow out.</p></blockquote><p>Just to reiterate, the first item in each vector is the inferred type of the
<em>inputs</em> and the remaining are the inferred types of the <em>outputs</em>.</p><p>As usual, let's just look at the first entry (the program entry) to test our
assumptions (it should be pretty boring). First let's look at the input types
to our program. We'll access the first element of the inner intmap, that is
stored in the first element of the vector that is stored in the first element
of our outter intmap. So we are looking at indices (0, 0, 0).</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (intmap-ref (vector-ref (intmap-ref hello-world-types 
                                                         0) 
                                             0) 
                                 0)
ice-9/boot-9.scm:1669:16: In procedure raise-exception:
not found 0

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt; ,q</code></pre><p>We get an error, though we shouldn't be surprised. The printed representation
of the first intmap in the first vector has no indices, because obviously the
entry point to our program has no inputs!</p><p>Let's look at the outputs, to do that we'll just look at index 1 of
the first vector. Looking at the printed representation it should have an entry
at index 0.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (intmap-ref (vector-ref (intmap-ref hello-world-types 
                                                         0) 
                                             1) 
                                 0)
$6 = #(67108863 -inf.0 +inf.0)</code></pre><p>Now we got a vector with a weird looking number at the front, and then two
trailing entries for <code>-inf.0</code> and <code>+inf.0</code>. So at least we immediately see the
variable can range from negative to positive infinity. But what is that first
number? Well let's remember the source comments</p><blockquote><p>An inferred type is a 3-vector of type, minimum, and maximum, where type is a
bitset as a fixnum.</p></blockquote><p>We clearly see the minimum and maximum, but what does the type mean. Well we can
find more clues in the exports from <code>language/cps/types.scm</code>. In particular the
module exports constants for all types starting on line 99 and ending on line 124.</p><p>It's a little hard to tell exactly what they all are from the source alone, but
I bet they are all integer constants. Let's see if I'm right by just
copy/pasting them into the repl</p><pre><code class="language-scheme">scheme@(guile-user)&gt; &amp;fixnum
$7 = 1
scheme@(guile-user)&gt; &amp;bignum
$8 = 2
scheme@(guile-user)&gt; &amp;flonum
$9 = 4
scheme@(guile-user)&gt; &amp;complex
$10 = 8
scheme@(guile-user)&gt; &amp;fraction
$11 = 16
scheme@(guile-user)&gt;
scheme@(guile-user)&gt; &amp;char
$12 = 32
scheme@(guile-user)&gt; &amp;special-immediate
$13 = 64
scheme@(guile-user)&gt; &amp;symbol
$14 = 128
scheme@(guile-user)&gt; &amp;keyword
$15 = 256
scheme@(guile-user)&gt; &amp;procedure
$16 = 512
scheme@(guile-user)&gt; &amp;pointer
$17 = 1024
scheme@(guile-user)&gt; &amp;fluid
$18 = 2048
scheme@(guile-user)&gt; &amp;pair
$19 = 4096
scheme@(guile-user)&gt; &amp;immutable-vector
$20 = 8192
scheme@(guile-user)&gt; &amp;mutable-vector
$21 = 16384
scheme@(guile-user)&gt; &amp;box
$22 = 32768
scheme@(guile-user)&gt; &amp;struct
$23 = 65536
scheme@(guile-user)&gt; &amp;string
$24 = 131072
scheme@(guile-user)&gt; &amp;bytevector
$25 = 262144
scheme@(guile-user)&gt; &amp;bitvector
$26 = 524288
scheme@(guile-user)&gt; &amp;array
$27 = 1048576
scheme@(guile-user)&gt; &amp;syntax
$28 = 2097152
scheme@(guile-user)&gt; &amp;other-heap-object
$29 = 4194304
scheme@(guile-user)&gt;
scheme@(guile-user)&gt; ;; Special immediate values.
scheme@(guile-user)&gt; &amp;null &amp;nil &amp;false &amp;true &amp;unspecified &amp;undefined &amp;eof
$30 = 0
$31 = 1
$32 = 2
$33 = 3
$34 = 4
$35 = 5
$36 = 6
scheme@(guile-user)&gt;
scheme@(guile-user)&gt; ;; Union types.
scheme@(guile-user)&gt; &amp;exact-integer &amp;exact-number &amp;real &amp;number &amp;vector
$37 = 3
$38 = 19
$39 = 23
$40 = 31
$41 = 24576
scheme@(guile-user)&gt;
scheme@(guile-user)&gt; ;; Untagged types.
scheme@(guile-user)&gt; &amp;f64
$42 = 8388608
scheme@(guile-user)&gt; &amp;u64
$43 = 16777216
scheme@(guile-user)&gt; &amp;s64
$44 = 33554432</code></pre><p>Well it sure seems like they are. It also seems like each one has just a single
bit set. So let's clean this up a bit and print the values with some padding so
we can compare them. First the regular <code>format</code> procedure isn't up to the task,
so we'll import the <code>ice-9</code> version that has hex/binary format strings. Then we
define a list of all the types. And then we'll loop through each of them
printing the hex, binary, symbol name, and decimal values for each type.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (use-modules (ice-9 format))
scheme@(guile-user)&gt; (define types 
                       '(&amp;fixnum
                         &amp;bignum
                         &amp;flonum
                         &amp;complex
                         &amp;fraction

                         &amp;char
                         &amp;special-immediate
                         &amp;symbol
                         &amp;keyword
                         &amp;procedure
                         &amp;pointer
                         &amp;fluid
                         &amp;pair
                         &amp;immutable-vector
                         &amp;mutable-vector
                         &amp;box
                         &amp;struct
                         &amp;string
                         &amp;bytevector
                         &amp;bitvector
                         &amp;array
                         &amp;syntax
                         &amp;other-heap-object

                         ;; Special immediate values.
                         &amp;null &amp;nil &amp;false &amp;true &amp;unspecified &amp;undefined &amp;eof

                         ;; Union types.
                         &amp;exact-integer &amp;exact-number &amp;real &amp;number &amp;vector

                         ;; Untagged types.
                         &amp;f64
                         &amp;u64
                         &amp;s64))
scheme@(guile-user)&gt; (for-each (lambda (type-pair) 
                                 (format #t &quot;~8,'0x ~32'0b ~a ~a\n&quot; (car type-pair)
                                                                    (car type-pair) 
                                                                    (cdr type-pair) 
                                                                    (car type-pair)))
                               ;; Here we combine the symbol name with the value of
                               ;; of the symbol. In the end we get something like this
                               ;; '((1 . &amp;fixnum) (2 . &amp;bignum) ...)
                               (map (lambda (type) 
                                      (cons (eval type (current-module)) type))
                                    types))
00000001 00000000000000000000000000000001 &amp;fixnum 1
00000002 00000000000000000000000000000010 &amp;bignum 2
00000004 00000000000000000000000000000100 &amp;flonum 4
00000008 00000000000000000000000000001000 &amp;complex 8
00000010 00000000000000000000000000010000 &amp;fraction 16
00000020 00000000000000000000000000100000 &amp;char 32
00000040 00000000000000000000000001000000 &amp;special-immediate 64
00000080 00000000000000000000000010000000 &amp;symbol 128
00000100 00000000000000000000000100000000 &amp;keyword 256
00000200 00000000000000000000001000000000 &amp;procedure 512
00000400 00000000000000000000010000000000 &amp;pointer 1024
00000800 00000000000000000000100000000000 &amp;fluid 2048
00001000 00000000000000000001000000000000 &amp;pair 4096
00002000 00000000000000000010000000000000 &amp;immutable-vector 8192
00004000 00000000000000000100000000000000 &amp;mutable-vector 16384
00008000 00000000000000001000000000000000 &amp;box 32768
00010000 00000000000000010000000000000000 &amp;struct 65536
00020000 00000000000000100000000000000000 &amp;string 131072
00040000 00000000000001000000000000000000 &amp;bytevector 262144
00080000 00000000000010000000000000000000 &amp;bitvector 524288
00100000 00000000000100000000000000000000 &amp;array 1048576
00200000 00000000001000000000000000000000 &amp;syntax 2097152
00400000 00000000010000000000000000000000 &amp;other-heap-object 4194304
00000000 00000000000000000000000000000000 &amp;null 0
00000001 00000000000000000000000000000001 &amp;nil 1
00000002 00000000000000000000000000000010 &amp;false 2
00000003 00000000000000000000000000000011 &amp;true 3
00000004 00000000000000000000000000000100 &amp;unspecified 4
00000005 00000000000000000000000000000101 &amp;undefined 5
00000006 00000000000000000000000000000110 &amp;eof 6
00000003 00000000000000000000000000000011 &amp;exact-integer 3
00000013 00000000000000000000000000010011 &amp;exact-number 19
00000017 00000000000000000000000000010111 &amp;real 23
0000001f 00000000000000000000000000011111 &amp;number 31
00006000 00000000000000000110000000000000 &amp;vector 24576
00800000 00000000100000000000000000000000 &amp;f64 8388608
01000000 00000001000000000000000000000000 &amp;u64 16777216
02000000 00000010000000000000000000000000 &amp;s64 33554432</code></pre><p>Well, I think that should satisfy our curiosity. It turns out we were <em>almost</em>
right. The &quot;raw&quot; types are indeed components of a bit mask. But thankfully
Guile has also conveniently provided us with some relevant unions. For
example the type code for number is <code>00000000000000000000000000011111</code> so that
encompasses all of the appropriate number subtypes. But does it answer our
question of what the number 67108863 means? An easy hypothesis to make is that
it is the union of <em>all</em> types. Let's test that theory at the repl!</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (apply logior (map (lambda (type)
                                          (eval type (current-module)))
                                        types))
$45 = 67108863</code></pre><p>And we get our magic number!. So the return type of the first function is <em>any</em>
scheme value! Now we should be able to go hunting in our intmap for a sensible
type, don't we have a constant string somewhere?</p><h4>Type Hunting</h4><p>If we examine the intmap for our types, we see something troubling. The
procedure body we are interested in seems to be missing. We only have entries
for the <code>$kfun</code> representing the entire program. The string we are looking for
only exists in the <code>main</code> procedure's body. So we'll want to go analyze that
instead. That's ok though, this should all look pretty familiar.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (define main-types (infer-types hello-world-cps 11))</code></pre><p>Now let's crack this intmap open and see what we have. If we look at index 6 of
our CPS intmap we can see that there should be a <code>&amp;string</code> type flowing into it
from the constant string at index 7. So we'll want to pull out the CPS value in
the <code>main-types</code> intmap for index 6, and then look at the first entry in the
vector that we get back.</p><pre><code class="language-scheme">scheme@(guile-user)&gt; (print-intmap (vector-ref (intmap-ref main-types 6) 0))
(5 #(67108863 -inf.0 +inf.0))
(6 #(67108863 -inf.0 +inf.0))
(7 #(131072 13 13))
(8 #(32768 2 +inf.0))
$46 = #&lt;intmap 5+0-3&gt;</code></pre><p>This seems to be the set of variables that our <code>main</code> procedure can see.</p><ul><li>At index 8 we see <code>32768</code> which is <code>&amp;box</code> with a range of 2 to +inf.0. This
is our <code>define</code> box.</li><li>At variable index 7 we see <code>131072</code> which is our <code>&quot;Hello world!\n&quot;</code> string
constant. You can see that Guile has even conveniently provided us with
bounds for the string's length! It is 13 characters long.</li><li>At index 6 we see <em>any</em> scheme type. Under our current assumptions this
should be our unboxed <code>display</code> function, so I would have expected to see
<code>512</code> for <code>&amp;procedure</code>. But perhaps that is just not something Guile infers
for us, or possibly this is due to not sorting our input intmap? A question
for another day though.</li><li>At index 5 we see another <em>any</em> scheme type. This one is a bit more puzzling,
as nowhere in our CPS intmap do we see a <code>$kargs</code> that stores a variable to
index 5. We'll also leave this as another question for another day.</li></ul><p>It seems that we haven't quite sorted everything out yet, but we certainly have
seen the tools that will help us fill in the gaps. We've also verified enough
of our assumptions that it seems pretty clear we are on the right track.</p><h3>Closing Thoughts</h3><p>There are still some open questions to this analysis.</p><ul><li>Why only one set of input types, but multiple sets of output types? My
initial hypothesis (that I have not yet tested) is that multiple output sets
would be needed when branching (for example with <code>if</code>).</li><li>There seems to be some relevance to the integers used to specify variables,
but I don't think I see what that significance is. And if there is
significance; is it intentional or coincidental?</li><li>We also haven't discussed at all the significance of Guile's type inferencer,
nor have we discussed alternatives. What can it do? What <em>can't</em> it do?</li></ul><p>At any rate, this post is already long enough, and we have covered our
hello-world example to my satisfaction. The rest will have to wait for another
time.</p><p>UPDATE: That time has come, see
<a href="/blog/understanding-the-guile-cps-variable-indices-moor-better.html">Understanding the Guile CPS Variable Indices Moor Better</a>.</p><h3>Appendix A</h3><p>Yes, I included the repl prompt in all the code snippets that I expected a
reader to copy/paste, which is just annoying. It means you have to copy paste
them all one at a time. So here is a big dump of the entire repl history. Now
you can dump this into your own repl and explore on your own!</p><p>Happy Hacking!</p><pre><code class="language-scheme">(define hello-world
  '(define (main)
    (display &quot;Hello world!\n&quot;)
    #;&quot;Hello world!\n&quot;))
(compile hello-world #:to 'cps)
(use-modules (language cps intmap))
(define hello-world-cps $1)
(intmap-ref hello-world-cps 0)
(use-modules (language cps utils))
(define (print-intmap intmap)
  (intmap-map (lambda entry
                (format #t &quot;~a\n&quot; entry))
              intmap))
(print-intmap hello-world-cps)
(use-modules (language cps types))
(infer-types hello-world-cps 0)
(define hello-world-types $4)
(print-intmap hello-world-types)
(intmap-ref (vector-ref (intmap-ref hello-world-types 
                                    0)
                        0) 
            0)
,q
(intmap-ref (vector-ref (intmap-ref hello-world-types 
                                    0) 
                        1) 
            0)
&amp;fixnum
&amp;bignum
&amp;flonum
&amp;complex
&amp;fraction

&amp;char
&amp;special-immediate
&amp;symbol
&amp;keyword
&amp;procedure
&amp;pointer
&amp;fluid
&amp;pair
&amp;immutable-vector
&amp;mutable-vector
&amp;box
&amp;struct
&amp;string
&amp;bytevector
&amp;bitvector
&amp;array
&amp;syntax
&amp;other-heap-object

;; Special immediate values.
&amp;null &amp;nil &amp;false &amp;true &amp;unspecified &amp;undefined &amp;eof

;; Union types.
&amp;exact-integer &amp;exact-number &amp;real &amp;number &amp;vector

;; Untagged types.
&amp;f64
&amp;u64
&amp;s64
(define types 
  '(&amp;fixnum
    &amp;bignum
    &amp;flonum
    &amp;complex
    &amp;fraction

    &amp;char
    &amp;special-immediate
    &amp;symbol
    &amp;keyword
    &amp;procedure
    &amp;pointer
    &amp;fluid
    &amp;pair
    &amp;immutable-vector
    &amp;mutable-vector
    &amp;box
    &amp;struct
    &amp;string
    &amp;bytevector
    &amp;bitvector
    &amp;array
    &amp;syntax
    &amp;other-heap-object

    ;; Special immediate values.
    &amp;null &amp;nil &amp;false &amp;true &amp;unspecified &amp;undefined &amp;eof

    ;; Union types.
    &amp;exact-integer &amp;exact-number &amp;real &amp;number &amp;vector

    ;; Untagged types.
    &amp;f64
    &amp;u64
    &amp;s64))
(use-modules (ice-9 format))
(for-each (lambda (type-pair) 
            (format #t &quot;~8,'0x ~32'0b ~a ~a\n&quot; (car type-pair)
                                               (car type-pair) 
                                               (cdr type-pair) 
                                               (car type-pair)))
          ;; Here we combine the symbol name with the value of
          ;; of the symbol. In the end we get something like this
          ;; '((1 . &amp;fixnum) (2 . &amp;bignum) ...)
          (map (lambda (type) 
                 (cons (eval type (current-module)) type))
               types))
(apply logior (map (lambda (type)
                     (eval type (current-module)))
                   types))
(define main-types (infer-types hello-world-cps 11))
(print-intmap (vector-ref (intmap-ref main-types 6) 0))</code></pre></div></div></body>